{"ast":null,"code":"import mimicFunction from 'mimic-function';\nconst maxTimeoutValue = 2_147_483_647;\nconst cacheStore = new WeakMap();\nconst cacheTimerStore = new WeakMap();\nconst cacheKeyStore = new WeakMap();\nfunction getValidCacheItem(cache, key) {\n  const item = cache.get(key);\n  if (!item) {\n    return undefined;\n  }\n  if (item.maxAge <= Date.now()) {\n    cache.delete(key);\n    return undefined;\n  }\n  return item;\n}\n/**\n[Memoize](https://en.wikipedia.org/wiki/Memoization) functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input.\n\n@param function_ - The function to be memoized.\n\n@example\n```\nimport memoize from 'memoize';\n\nlet index = 0;\nconst counter = () => ++index;\nconst memoized = memoize(counter);\n\nmemoized('foo');\n//=> 1\n\n// Cached as it's the same argument\nmemoized('foo');\n//=> 1\n\n// Not cached anymore as the arguments changed\nmemoized('bar');\n//=> 2\n\nmemoized('bar');\n//=> 2\n```\n*/\nexport default function memoize(function_, {\n  cacheKey,\n  cache = new Map(),\n  maxAge\n} = {}) {\n  if (maxAge === 0) {\n    return function_;\n  }\n  if (typeof maxAge === 'number' && Number.isFinite(maxAge)) {\n    if (maxAge > maxTimeoutValue) {\n      throw new TypeError(`The \\`maxAge\\` option cannot exceed ${maxTimeoutValue}.`);\n    }\n    if (maxAge < 0) {\n      throw new TypeError('The `maxAge` option should not be a negative number.');\n    }\n  }\n  const memoized = function (...arguments_) {\n    const key = cacheKey ? cacheKey(arguments_) : arguments_[0];\n    const cacheItem = getValidCacheItem(cache, key);\n    if (cacheItem) {\n      return cacheItem.data;\n    }\n    const result = function_.apply(this, arguments_);\n    const computedMaxAge = typeof maxAge === 'function' ? maxAge(...arguments_) : maxAge;\n    if (computedMaxAge !== undefined && computedMaxAge !== Number.POSITIVE_INFINITY) {\n      if (!Number.isFinite(computedMaxAge)) {\n        throw new TypeError('The `maxAge` function must return a finite number, `0`, or `Infinity`.');\n      }\n      if (computedMaxAge <= 0) {\n        return result; // Do not cache\n      }\n      if (computedMaxAge > maxTimeoutValue) {\n        throw new TypeError(`The \\`maxAge\\` function result cannot exceed ${maxTimeoutValue}.`);\n      }\n    }\n    cache.set(key, {\n      data: result,\n      maxAge: computedMaxAge === undefined || computedMaxAge === Number.POSITIVE_INFINITY ? Number.POSITIVE_INFINITY : Date.now() + computedMaxAge\n    });\n    if (computedMaxAge !== undefined && computedMaxAge !== Number.POSITIVE_INFINITY) {\n      const timer = setTimeout(() => {\n        cache.delete(key);\n        cacheTimerStore.get(memoized)?.delete(timer);\n      }, computedMaxAge);\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      timer.unref?.();\n      const timers = cacheTimerStore.get(memoized) ?? new Set();\n      timers.add(timer);\n      cacheTimerStore.set(memoized, timers);\n    }\n    return result;\n  };\n  mimicFunction(memoized, function_, {\n    ignoreNonConfigurable: true\n  });\n  cacheStore.set(memoized, cache);\n  cacheKeyStore.set(memoized, cacheKey ?? (arguments_ => arguments_[0]));\n  return memoized;\n}\n/**\n@returns A [decorator](https://github.com/tc39/proposal-decorators) to memoize class methods or static class methods.\n\n@example\n```\nimport {memoizeDecorator} from 'memoize';\n\nclass Example {\n    index = 0\n\n    @memoizeDecorator()\n    counter() {\n        return ++this.index;\n    }\n}\n\nclass ExampleWithOptions {\n    index = 0\n\n    @memoizeDecorator({maxAge: 1000})\n    counter() {\n        return ++this.index;\n    }\n}\n```\n*/\nexport function memoizeDecorator(options = {}) {\n  const instanceMap = new WeakMap();\n  return (target, propertyKey, descriptor) => {\n    const input = target[propertyKey]; // eslint-disable-line @typescript-eslint/no-unsafe-assignment\n    if (typeof input !== 'function') {\n      throw new TypeError('The decorated value must be a function');\n    }\n    delete descriptor.value;\n    delete descriptor.writable;\n    descriptor.get = function () {\n      if (!instanceMap.has(this)) {\n        const value = memoize(input, options);\n        instanceMap.set(this, value);\n        return value;\n      }\n      return instanceMap.get(this);\n    };\n  };\n}\n/**\nClear all cached data of a memoized function.\n\n@param function_ - The memoized function.\n*/\nexport function memoizeClear(function_) {\n  const cache = cacheStore.get(function_);\n  if (!cache) {\n    throw new TypeError('Can\\'t clear a function that was not memoized!');\n  }\n  if (typeof cache.clear !== 'function') {\n    throw new TypeError('The cache Map can\\'t be cleared!');\n  }\n  cache.clear();\n  for (const timer of cacheTimerStore.get(function_) ?? []) {\n    clearTimeout(timer);\n  }\n  cacheTimerStore.delete(function_);\n}\n/**\nCheck if a specific set of arguments is cached for a memoized function.\n\n@param function_ - The memoized function.\n@param arguments_ - The arguments to check.\n@returns `true` if the arguments are cached and not expired, `false` otherwise.\n\nUses the same argument processing as the memoized function, including any custom `cacheKey` function.\n\n@example\n```\nimport memoize, {memoizeIsCached} from 'memoize';\n\nconst expensive = memoize((a, b) => a + b, {cacheKey: JSON.stringify});\nexpensive(1, 2);\n\nmemoizeIsCached(expensive, 1, 2);\n//=> true\n\nmemoizeIsCached(expensive, 3, 4);\n//=> false\n```\n*/\nexport function memoizeIsCached(function_, ...arguments_) {\n  const cacheKey = cacheKeyStore.get(function_);\n  if (!cacheKey) {\n    return false;\n  }\n  const cache = cacheStore.get(function_);\n  const key = cacheKey(arguments_);\n  const item = getValidCacheItem(cache, key);\n  return item !== undefined;\n}","map":{"version":3,"names":["mimicFunction","maxTimeoutValue","cacheStore","WeakMap","cacheTimerStore","cacheKeyStore","getValidCacheItem","cache","key","item","get","undefined","maxAge","Date","now","delete","memoize","function_","cacheKey","Map","Number","isFinite","TypeError","memoized","arguments_","cacheItem","data","result","apply","computedMaxAge","POSITIVE_INFINITY","set","timer","setTimeout","unref","timers","Set","add","ignoreNonConfigurable","memoizeDecorator","options","instanceMap","target","propertyKey","descriptor","input","value","writable","has","memoizeClear","clear","clearTimeout","memoizeIsCached"],"sources":["C:/Users/nagad/OneDrive/Documents/Desktop/studybuddy/frontend/node_modules/memoize/distribution/index.js"],"sourcesContent":["import mimicFunction from 'mimic-function';\nconst maxTimeoutValue = 2_147_483_647;\nconst cacheStore = new WeakMap();\nconst cacheTimerStore = new WeakMap();\nconst cacheKeyStore = new WeakMap();\nfunction getValidCacheItem(cache, key) {\n    const item = cache.get(key);\n    if (!item) {\n        return undefined;\n    }\n    if (item.maxAge <= Date.now()) {\n        cache.delete(key);\n        return undefined;\n    }\n    return item;\n}\n/**\n[Memoize](https://en.wikipedia.org/wiki/Memoization) functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input.\n\n@param function_ - The function to be memoized.\n\n@example\n```\nimport memoize from 'memoize';\n\nlet index = 0;\nconst counter = () => ++index;\nconst memoized = memoize(counter);\n\nmemoized('foo');\n//=> 1\n\n// Cached as it's the same argument\nmemoized('foo');\n//=> 1\n\n// Not cached anymore as the arguments changed\nmemoized('bar');\n//=> 2\n\nmemoized('bar');\n//=> 2\n```\n*/\nexport default function memoize(function_, { cacheKey, cache = new Map(), maxAge, } = {}) {\n    if (maxAge === 0) {\n        return function_;\n    }\n    if (typeof maxAge === 'number' && Number.isFinite(maxAge)) {\n        if (maxAge > maxTimeoutValue) {\n            throw new TypeError(`The \\`maxAge\\` option cannot exceed ${maxTimeoutValue}.`);\n        }\n        if (maxAge < 0) {\n            throw new TypeError('The `maxAge` option should not be a negative number.');\n        }\n    }\n    const memoized = function (...arguments_) {\n        const key = cacheKey ? cacheKey(arguments_) : arguments_[0];\n        const cacheItem = getValidCacheItem(cache, key);\n        if (cacheItem) {\n            return cacheItem.data;\n        }\n        const result = function_.apply(this, arguments_);\n        const computedMaxAge = typeof maxAge === 'function' ? maxAge(...arguments_) : maxAge;\n        if (computedMaxAge !== undefined && computedMaxAge !== Number.POSITIVE_INFINITY) {\n            if (!Number.isFinite(computedMaxAge)) {\n                throw new TypeError('The `maxAge` function must return a finite number, `0`, or `Infinity`.');\n            }\n            if (computedMaxAge <= 0) {\n                return result; // Do not cache\n            }\n            if (computedMaxAge > maxTimeoutValue) {\n                throw new TypeError(`The \\`maxAge\\` function result cannot exceed ${maxTimeoutValue}.`);\n            }\n        }\n        cache.set(key, {\n            data: result,\n            maxAge: (computedMaxAge === undefined || computedMaxAge === Number.POSITIVE_INFINITY)\n                ? Number.POSITIVE_INFINITY\n                : Date.now() + computedMaxAge,\n        });\n        if (computedMaxAge !== undefined && computedMaxAge !== Number.POSITIVE_INFINITY) {\n            const timer = setTimeout(() => {\n                cache.delete(key);\n                cacheTimerStore.get(memoized)?.delete(timer);\n            }, computedMaxAge);\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            timer.unref?.();\n            const timers = cacheTimerStore.get(memoized) ?? new Set();\n            timers.add(timer);\n            cacheTimerStore.set(memoized, timers);\n        }\n        return result;\n    };\n    mimicFunction(memoized, function_, {\n        ignoreNonConfigurable: true,\n    });\n    cacheStore.set(memoized, cache);\n    cacheKeyStore.set(memoized, (cacheKey ?? ((arguments_) => arguments_[0])));\n    return memoized;\n}\n/**\n@returns A [decorator](https://github.com/tc39/proposal-decorators) to memoize class methods or static class methods.\n\n@example\n```\nimport {memoizeDecorator} from 'memoize';\n\nclass Example {\n    index = 0\n\n    @memoizeDecorator()\n    counter() {\n        return ++this.index;\n    }\n}\n\nclass ExampleWithOptions {\n    index = 0\n\n    @memoizeDecorator({maxAge: 1000})\n    counter() {\n        return ++this.index;\n    }\n}\n```\n*/\nexport function memoizeDecorator(options = {}) {\n    const instanceMap = new WeakMap();\n    return (target, propertyKey, descriptor) => {\n        const input = target[propertyKey]; // eslint-disable-line @typescript-eslint/no-unsafe-assignment\n        if (typeof input !== 'function') {\n            throw new TypeError('The decorated value must be a function');\n        }\n        delete descriptor.value;\n        delete descriptor.writable;\n        descriptor.get = function () {\n            if (!instanceMap.has(this)) {\n                const value = memoize(input, options);\n                instanceMap.set(this, value);\n                return value;\n            }\n            return instanceMap.get(this);\n        };\n    };\n}\n/**\nClear all cached data of a memoized function.\n\n@param function_ - The memoized function.\n*/\nexport function memoizeClear(function_) {\n    const cache = cacheStore.get(function_);\n    if (!cache) {\n        throw new TypeError('Can\\'t clear a function that was not memoized!');\n    }\n    if (typeof cache.clear !== 'function') {\n        throw new TypeError('The cache Map can\\'t be cleared!');\n    }\n    cache.clear();\n    for (const timer of cacheTimerStore.get(function_) ?? []) {\n        clearTimeout(timer);\n    }\n    cacheTimerStore.delete(function_);\n}\n/**\nCheck if a specific set of arguments is cached for a memoized function.\n\n@param function_ - The memoized function.\n@param arguments_ - The arguments to check.\n@returns `true` if the arguments are cached and not expired, `false` otherwise.\n\nUses the same argument processing as the memoized function, including any custom `cacheKey` function.\n\n@example\n```\nimport memoize, {memoizeIsCached} from 'memoize';\n\nconst expensive = memoize((a, b) => a + b, {cacheKey: JSON.stringify});\nexpensive(1, 2);\n\nmemoizeIsCached(expensive, 1, 2);\n//=> true\n\nmemoizeIsCached(expensive, 3, 4);\n//=> false\n```\n*/\nexport function memoizeIsCached(function_, ...arguments_) {\n    const cacheKey = cacheKeyStore.get(function_);\n    if (!cacheKey) {\n        return false;\n    }\n    const cache = cacheStore.get(function_);\n    const key = cacheKey(arguments_);\n    const item = getValidCacheItem(cache, key);\n    return item !== undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}